\newpage
{
\section{The \ISETL{} Grammar --- Annotated}	%\samepage
\index{grammar}

\subsection{Terminology}

\begin{enumerate}

\item
In what follows, the symbol \[ID\] refers to identifiers,
and \[INTEGER\], \[FLOAT\-ING\_\,POINT\],
\[BOOLEAN\], and \[STRING\] refer to 
constants of type
integer, floating\_\,point, Boolean, and string,
which have been explained above.
Any other symbol in capital letters is explained in the grammar.

\item
Definitions appear as:
\HEAD{STMT}
\RULE{LHS := EXPR ;}
\RULE{if EXPR then STMTS ELSE-IFS ELSE-PART end}

\noindent
indicating that \[STMT\] can be either an assignment statement or 
a conditional statement.
The definitions for \[ELSE-IFS\] and \[ELSE-PART\] are in the
section for statements, and \[EXPR\] in the section for expressions.

\item
Rules are sometimes given informally in English.
The rule is then quoted.

\item
Spaces are not allowed within any of the character pairs
listed in section~\ref{char-key},
nor within an \[ID\], \[INTEGER\] constant,
\[FLOATING\_\,POINT\] constant, or keyword.
Spaces are required between keywords, \[ID\]s, \[INTEGER\] constants,
and \[FLOATING\_\,POINT\] constants.

\item
\ISETL{} treats ends of line and tabs as spaces.
Any input can be spread across lines without changing the meaning,
and \ISETL{} will not
consider it to be complete until a semicolon (``\[;\]'') is entered.
\index{! tt (directives)}
The only exceptions to this are the \[!\]~directives,
which are ended with a carriage return,
and the fact that a quoted string cannot be typed on more than one line.
\end{enumerate}


The annotated grammar below is divided into sections relating to the
major parts of the language.

\subsection{Input at the Prompt}

\HEAD{INPUT}
\RULE{PROGRAM}
\RULE{STMT}
\RULE{EXPR ;}
\COMMENT{The \[EXPR\] is evaluated
and the value is printed.}

\subsection{Program}
Programs are usually read from a file, only because they tend to be
long.

\HEAD{PROGRAM}
\RULE{program ID ; LOCALS VALUES STMTS  end ;}
\COMMENT{Of course, it can appear on several lines.
One may optionally close with \[end~program\].
\[LOCALS\] and \[VALUES\] are defined in section~\ref{func-const}.
}

\subsection{Statements}
\HEAD{STMT}
\RULE{LHS := EXPR ;}
\key{:=}
\COMMENT{
First, the left hand side (\[LHS\]) is evaluated to determine
the target(s) for the assignment,
then the right hand side is evaluated.
Finally, the assignment is made.
If there are some targets for which there
are no values to be assigned, they receive the
value \[OM\]\@.  If there are values to be assigned, but
no corresponding targets, then the values are ignored.

Examples:

\begin{indented}
\verb|a := 4;|
    \begin{indented}
    \[a\] is changed to contain the value \(4\).
    \end{indented}

\verb|[a,b] := [1,2];|
    \begin{indented}
    \[a\] is assigned \(1\) and \[b\] is assigned \(2\).
    \end{indented}


\verb|[x,y] := [y,x];|
    \begin{indented}
    Swap \[x\] and \[y\].
    \end{indented}


\verb|f(3) := 7;|
    \begin{indented}
    If \[f\] is a tuple, then the effect of this statement
    is to assign \(7\) as the value of the third component of \[f\].
    If \[f\] is a map, then its effect is to replace all pairs beginning
    with \(3\) by the pair \[[3,7]\] in the set of ordered pairs \[f\].
    If \[f\] is a func, then \[f(3)\] will be \(7\), and all other values
    of \[f\] will be as they were before the assignment.
    \end{indented}
\end{indented}
}

\RULE{EXPR ;}
\COMMENT{The expression is evaluated and the value ignored.
This is usually used to invoke procedures.}

\RULE{if EXPR then STMTS ELSE-IFS ELSE-PART end ;}\label{if-stmt}
\key{if}\key{then}\key{else}\key{elseif}\key{end}
\COMMENT{
The \[EXPR\]s after \[if\] and \[elseif\] are evaluated in order until one
is found to be true.
The \[STMTS\] following the associated \[then\] are executed.
If no \[EXPR\] is found to be true,
the \[STMTS\] in the \[ELSE-PART\] are executed.
In this last case, if the \[ELSE-PART\] is omitted, this statement
has no effect.
One may optionally close with \[end~if\].
See the end of this section for the definitions of \[ELSE-IFS\]
and \[ELSE-PART\]\@.}

\RULE{for   ITERATOR do STMTS end ;}
\key{for}\key{do}\key{end}
\COMMENT{The \[STMTS\] are executed for each instance generated by the
iterator.
One may optionally close with \[end~for\].}

\RULE{while EXPR do STMTS end ;}
\key{while}
\COMMENT{\[EXPR\] must evaluate to a Boolean value.  \[EXPR\] is evaluated
and the \[STMTS\] are executed repetitively as long as this
value is equal to true.
One may optionally close with \[end~while\].}

\RULE{read LHS-LIST ;}
\key{read}\key{from}
\COMMENT{\ISETL{} gives a question mark (``\[?\]'') prompt and waits until an
expression has been entered.  
This \[EXPR\] is evaluated and
the result is assigned to the first item in \[LHS-LIST\]\@.  
This is repeated for each item in \[LHS-LIST\]\@.
As usual, terminate the expressions with a semicolon.
{\em Note:\/} If a \[read\] statement appears in an \[!include\] file,
then \ISETL{} will look at the next input in that
file for the expression(s) to be read.}

\RULE{read LHS-LIST from EXPR ;}
\COMMENT{This is the same as \[read LHS-LIST;\] except that \[EXPR\]
must have a value of type file.  The values to be read
are then taken from the external file specified by the
value of \[EXPR\]\@.
If there are more values in the file than items in \[LHS-LIST\],
then the extra values are left to be read later.  If there
are more items in \[LHS-LIST\] than values in the file, then
the extra items are assigned the value \[OM\]\@.  In the latter
case, the function \[eof\] will return true when given the file as
parameter.
Before this statement is executed, the external file in
question must have been opened for reading by the
pre-defined function \[openr\] (see section~\ref{file-func}).}

\RULE{readf PAIR-LIST ;}
\RULE{readf PAIR-LIST from EXPR ;}
\COMMENT{
The relation between these two forms is the same as the relation
between the two forms of \[read\], with the second one coming from a file.
The elements in the \[PAIR-LIST\] define the formating used.
See \[PAIR-LIST\] at the end of this section.
}

\RULE{print EXPR-LIST ;}
\key{print}\key{to}
\COMMENT{Each expression in \[EXPR-LIST\] is evaluated and printed on
standard output. The output values are formated to show
their structure, with line breaks at reasonable positions
and meaningful indentation.  }

\RULE{print EXPR-LIST to EXPR ;}
\COMMENT{As in \[read\ldots from\ldots\],
\[EXPR\] must be a value of type file.
The values are written to the external file specified
by the value of \[EXPR\]\@.
Before executing this statement, the external file
in question must have been opened for writing by
one of the pre-defined functions \[openw\] or \[opena\]
(see section~\ref{file-func}).}

\RULE{printf PAIR-LIST ;}
\RULE{printf PAIR-LIST to EXPR ;}
\key{print}\key{printf}
\COMMENT{
The relation between these two forms is the same as the relation
between the two forms of \[print\], with the second one going to a
file.
The elements in the \[PAIR-LIST\] define the formating used.
See \[PAIR-LIST\] at the end of this section.
See \[write\] and \[writeln\] below.
}

\RULE{return ;}\label{return}
\key{return}
\COMMENT{
\[return\] is only meaningful inside a func.
Its effect is to terminate execution of
the func and return \[OM\] to the caller.
\ISETL{} inserts \[return;\] just before the \[end\] of every func.
If \[return\] appears at the ``top level'', e.g. as input at the
keyboard, a run time error will occur.
}

\RULE{return EXPR ;}
\COMMENT{Same as \[return;\] except that \[EXPR\] is evaluated and its
value is returned as the value of the func.}

\RULE{take LHS from LHS ;}
\key{take}\key{from} \key{fromb}\key{frome}
\COMMENT{The second \[LHS\] must evaluate to a set.  An arbitrary
element of the set is assigned to the
first \[LHS\] and removed from the set.}

\RULE{take LHS frome LHS ;}
\COMMENT{The second \[LHS\] must evaluate to a tuple (or a string).
The value of its
last defined component (or last character)
is assigned to the first \[LHS\] and
replaced by \[OM\] in the tuple (deleted from the string).}

\RULE{take LHS fromb LHS ;}
\COMMENT{The second \[LHS\] must evaluate to a tuple (or a string).
The value of its
first component (defined or not) (first character) is assigned to the first
\[LHS\] and all components of the tuple (characters of the string)
are shifted left one place.
That is, the new value of the $i^{th}$ component is the
old value of the $(i+1)^{st}$ component ($i = 1,2,\ldots$).}

\RULE{write PAIR-LIST ;}
\RULE{write PAIR-LIST to EXPR ;}
\RULE{writeln PAIR-LIST ;}
\RULE{writeln PAIR-LIST to EXPR ;}
\COMMENT{\[write\] is equivalent to \[printf\], provided for the
convenience of the Pascal user.
\[writeln\] is equivalent to \[write\], with \['\esc n'\] as the last
item of the list.  This is also provided for user convenience.}

\HEAD{STMTS}
\RULE{\rm ``One or more instances of \[STMT\].
The final semicolon is optional.''}

\HEAD{ELSE-IFS}
\RULE{\rm ``Zero or more instances of \[ELSE-IF\].''}

\HEAD{ELSE-IF}
\RULE{elseif EXPR then STMTS}

\HEAD{ELSE-PART}
\RULE{else STMTS}
\COMMENT{\rm ``May be omitted.''}

\HEAD{PAIR-LIST}
\RULE{\rm ``One or more instances of \[PAIR\], separated by commas.''}

\HEAD{PAIR}
\RULE{EXPR : EXPR}
\RULE{EXPR}
\begin{figure}
\begin{indented}\begin{indented}
\begin{verbatim}
>       readf x;
   1.34
>       x;
1.34000e+00;

>       readf y;
123,456
>       y;
"123,456";
\end{verbatim}
\end{indented}\end{indented}
\caption{\[readf\] example\label{readf}}
\end{figure}

\begin{figure}
\begin{indented}\begin{indented}
\begin{verbatim}
>       printf 1/3: 15.10,  1/3:15.1,  1/3:15.01, "\n";
0.3333333135   0.3333333135            0.3

printf 1/3: -17.10, 1/3:-17.1, 1/3:-17.01, "\n";
3.3333331347e-01 3.3333331347e-01          3.3e-01
\end{verbatim}
\end{indented}\end{indented}
\caption{\[printf\] example\label{printf}}
\end{figure}

\begin{figure}
\begin{indented}\begin{indented}
\begin{verbatim}
>       printf 3*[""]+[1..30] : 7*[3] with "\n";
           1  2  3  4
  5  6  7  8  9 10 11
 12 13 14 15 16 17 18
 19 20 21 22 23 24 25
 26 27 28 29 30
>       x := [ [i,j,i+j] : i,j in [1..3] ];
>       printf x: 5*[ [0,"+",0, "=", 0], "\t" ] 
>>                  with "\n", "\n";
1+1=2   1+2=3   1+3=4   2+1=3   2+2=4   
2+3=5   3+1=4   3+2=5   3+3=6
\end{verbatim}
\end{indented}\end{indented}
\caption{\[printf\] with structure example\label{compound}}
\end{figure}


\COMMENT{
When a \[PAIR\] appears in a \[readf\], the first \[EXPR\] must be a
\[LHS\].
The meaning of the \[PAIR\] and the default value when the second
\[EXPR\] is omitted depends on whether the \[PAIR\] occurs in
\[readf\] or \[printf\].  The second \[EXPR\] (or its default value)
defines the format.

\begin{itemize}

\item
Input: Input formats are integers.

\nopagebreak
    The integer gives the maximum number of characters to be read.
    If the first sequence of non-white space characters can be
    interpreted as a number, that is the value read.
    Otherwise, the first non-white sequence is returned as a string.

    If the integer is negative (say $-i$), exactly $i$ characters will be
    read and returned as a string.  Therefore \[c:-1\] will read one
    character into \[c\].

    If no integer is given, there is no maximum to the number of
    characters that will be read.

    See figure~\ref{readf}.

\item
Output: Output formats are: integers, floating\_\,point numbers,
strings, or tuples of output formats.

    Integers (and the integer part of floating\_\,point numbers)
    represent the minimal number of columns to be used.  
    The fractional part of a floating\_\,point number is used to
    specify precision, in terms of hundredths.  
    The precision controls the
    number of places used in floating\_\,point numbers,
    and where breaks occur in very long integers.

    Negative values cause floating\_\,point numbers to be printed
    in scientific notation.

    Notice that there is a limit to the number of useful digits.  Also
    notice that 15.1 is the same as 15.10;
    hence, both would use 15 columns and 10 decimal places.
    See figure~\ref{printf}.

    Strings should not be used as formats outside of tuples.

    Compound objects (tuples and sets) iterate over the format.
    If the format is a number,
    it is used as the format for each element.  
    If the format is a tuple,
    the elements of the tuple are cycled among,
    with strings printed literally and other items used as formats.
    See figure~\ref{compound}.

    Default values are:
    
\CS
\begin{tabular}{l r l}
    Type&	Columns&	Precision\\\hline
    Float&	20&	5\\
    Integer&	10&	50 (for breaking large ints)\\
    String&	0\\
    Anything else&	10
\end{tabular}
\CE
\end{itemize}
}

\subsection{Iterators}
These constructs are used to iterate through a collection of values,
assigning these values one at a time to a variable.
Iterators are used in the \[for\]~statement, quantifiers, and set
formers.

A \[SIMPLE-ITERATOR\] generates a number of instances for
which an assignment is made.  These assignments are
local to the iterator, and when it is exited, all
previous values of \[ID\]s that were used as local
variables are restored.  That is, these \[ID\]s are
``bound variables'' whose scope is the construction containing the
iterator.\index{bound variable}\index{scope}
(e.g., \[for\]~statements, quantifiers, formers, etc. )

\HEAD{ITERATOR}
\RULE{ITER-LIST}

\RULE{ITER-LIST | EXPR}
\COMMENT{\[EXPR\] must evaluate to a Boolean.  Generates only those
instances generated by \[ITER-LIST\] for which the
value of \[EXPR\] is true.}

\HEAD{ITER-LIST}
\RULE{\rm ``One or more \[SIMPLE-ITERATOR\]s separated by commas.''}
\COMMENT{\sloppy
Generates all possible instances for every combination
of the \[SIMPLE-ITERATOR\]s.  The first \[SIMPLE-ITERATOR\]
advances most slowly.  Subsequent iterators may
depend on previously bound values.}

\HEAD{SIMPLE-ITERATOR}
\RULE{BOUND-LIST in EXPR}
\key{in}
\COMMENT{\[EXPR\] must evaluate to a set, tuple, or string.
The instances generated are all possibilities in which
each \[BOUND\] in \[BOUND-LIST\] is assigned a value
that occurs in \[EXPR\]\@.}

\RULE{BOUND = ID ( BOUND-LIST )}
\COMMENT{Here \[ID\] must have the value of an 
smap, tuple, or string,
and \[BOUND-LIST\] must have the correct number of occurrences of
\[BOUND\] corresponding to the parameters of \[ID\]\@.
The resulting instances are
those for which all occurrences of \[BOUND\] in \[BOUND-LIST\] have all
possible legal values and \[BOUND\] is assigned the corresponding
value.}

\RULE{BOUND = ID \{ BOUND-LIST \} }
\COMMENT{Same as the previous one for the case in which \[ID\] is an
mmap.}

\HEAD{BOUND-LIST}
\RULE{\rm ``one or more \[BOUND\], separated by commas'' }

\HEAD{BOUND}
\RULE{\~{}}\key{ztilde}
\COMMENT{Corresponding value is thrown away.}

\RULE{ID }
\COMMENT{Corresponding value is assigned to \[ID\]\@.}

\RULE{[ BOUND-LIST ] }
\COMMENT{Corresponding value must be a tuple, and elements of
the tuple are assigned to corresponding elements in
the \[BOUND-LIST\]\@.}

\subsection{Formers}
Generates the elements of a set or tuple.

\HEAD{FORMER}
\RULE{\rm ``Empty''}
\COMMENT{Generates the empty set or tuple.}

\RULE{EXPR-LIST }
\COMMENT{Values are explicitly listed.}

\RULE{EXPR ..\ EXPR }
\key{..}
\COMMENT{Both occurrences of \[EXPR\] must evaluate to integers or
characters (strings of length 1).
Generates all integers (characters) beginning with the first \[EXPR\]
and increasing by 1 for as long as the second \[EXPR\]
is not exceeded.  If the first \[EXPR\] is larger than the
second, no values are generated.  The characters are generated in
ASCII order.}

\RULE{EXPR , EXPR ..\ EXPR }
\COMMENT{All three occurrences of \[EXPR\] must evaluate to numbers.
Generates all numbers beginning with the first \[EXPR\]
and incrementing by the value of the second \[EXPR\] minus
the first \[EXPR\]\@.  If this difference is positive, it
generates those values that are not greater than
the third \[EXPR\]\@.  If the difference is negative, it
generates those values that are not less than the
third \[EXPR\]\@.  If the difference is zero, no values
are generated.}

\RULE{EXPR : ITERATOR }
\COMMENT{The value of \[EXPR\] for each instance generated by the
\[ITERATOR\]\@.}

\subsection{Selectors}\label{selector}
Selectors fall into three categories: function application,
\index{function\\application}
\index{mmap tt}
\index{image}
\index{smap tt}
\index{slice}
mmap images, and slices.
\index{map}
A \XX{tuple}, \XX{string}, \[map\], or \TT{func}
(pre- or user-defined) may be followed by a \[SELECTOR\],
which has the effect of specifying a value or group of values in the
range of the tuple, string, map, or func.  
Not all of the following \[SELECTOR\]s can be used in all four cases.
\HEAD{SELECTOR}
\RULE{( EXPR-LIST ) }
\COMMENT{Must be used with an smap, tuple, string, or
func.  

If used with a tuple or string, then
\[EXPR-LIST\] can only have one element, which must evaluate
to a positive integer.  

If used with a func, arguments are passed to corresponding
parameters.  There must be as many arguments as required parameters
and no more than the optional parameters permit.

If used with an smap and \[EXPR-LIST\] has more than
one element, it is equivalent to what it would be if the
list were enclosed in square brackets, \[[ ]\].  Thus a
function of several variables is interpreted as a
function of one variable --- the tuple whose
components are the individual variables.}%
\index{function}%
\index{function\\of several variables}

\RULE{\{ EXPR-LIST \} }
\COMMENT{Must be used with an mmap, tuple, or string.
Tuples and strings will either select a singleton set or the empty set.
The case in which the list has more than one element
is handled as above.}

\RULE{( EXPR ..\ EXPR ) }
\key{..}
\COMMENT{Must be used with a tuple or string, and both instances
of \[EXPR\] must evaluate to a positive integer.

The value is the slice of the original tuple or string in
the range specified by the two occurrences of \[EXPR\]\@.
There are some special rules in this case.
To describe them, suppose that the first \[EXPR\] has the
value \[a\] and the second has the value \[b\] so that the
selector is \[(a..b)\].

    \begin{center}
    \begin{tabular}{l l}
    $a \leq b$&	Value is the tuple or string with components\\
	    &defined only at the integers from $1$ to $b-a+1$,\\
	    &inclusive.  The value of the $i^{th}$ component is\\
	    &the value of the $(a+i-1)^{st}$ component of the\\
	    &value of \[EXPR\]\@.\\
    $a = b+1$&	Value is the empty tuple.\\
    $a > b+1$&  Run-time error.\\
    \end{tabular}
    \end{center}
}

\RULE{( ..\ EXPR ) }
\COMMENT{Means the same as \[(low ..\ EXPR)\], where
\[low\] is 1 for strings and \[lo(T)\] for tuple \[T\].}

\RULE{( EXPR ..\ ) }
\COMMENT{Means the same as \[( EXPR ..\ high )\],
where \[high\] is \[\#s\] for string \[s\] and \[hi(T)\] for tuple \[T\].}

\RULE{( ) }
\COMMENT{Used with a func that has no parameters.  It also
works with an smap with \[[ ]\] in its domain.}

\subsection{Left Hand Sides}
The target for anything that has the effect of an
assignment.

\nopagebreak
\HEAD{LHS}
\RULE{ID }

\RULE{@ EXPR}\key{@}
\RULE{@ ( EXPR , EXPR , ... , EXPR)}
\COMMENT{These are variables and may be used wherever a variable is needed.
    {\it NB:} The ids in declarations and binding positions (iterators) are
    not variables and cannot be \[@\]-expressions.

    The expressions may be strings or integers.  The integers are
    converted to strings and the strings are then concatenated to
    produce the variable name.}



\RULE{LHS SELECTOR }
\COMMENT{\[LHS\] must evaluate to a tuple, string, or map.
\[LHS\] is modified by replacing the components designated by selector.}

\RULE{[ LHS-LIST ]}

\HEAD{LHS-LIST}
\RULE{\rm ``One or more instances of \[LHS\], separated by commas''}
\COMMENT{Thus the input,

    \DS [A, B, C] := [1, 2, 3]; \DE

has the effect of replacing \[A\] by \(1\), \[B\] by \(2\),
and \[C\] by \(3\).

Any \[LHS\] in the list can be replaced by \~{}.

The effect is to omit any assignment to a \[LHS\] that has
been so replaced.  Thus the input,

    \DS [A, \~{}, C] := [1, 2, 3]; \DE

replaces \[A\] by \(1\), \[C\] by \(3\).}

\pagebreak[3]
\subsection{Expressions}
The first few in the following list are values of
simple data types and they have been discussed
before.

\HEAD{EXPR}
\RULE{ID}\key{ID}

\RULE{INTEGER}\key{INTEGER}

\RULE{FLOATING-POINT}\key{FLOATING-POINT}

\RULE{STRING}\key{STRING}

\RULE{true}\key{true}

\RULE{false}\key{false}

\RULE{OM}\key{OM}

\RULE{newat}\key{newat}
\COMMENT{The value is a new atom, different from any other
atom that has appeared before.}

\RULE{FUNC-CONST}\key{FUNC-CONST}
\COMMENT{A user-defined func.  See section~\ref{func-const}.}

\RULE{if EXPR then EXPR ELSE-IFS ELSE-PART end ;}
\COMMENT{See definition of \[if\] under \[STMT\], page\pageref{if-stmt}.
If \[ELSE-PART\] is omitted, it is replaced by ``\[else OM\]''.
Each part contains an expression rather
than statements.}

\RULE{( EXPR )}
\COMMENT{Any expression can be enclosed in parentheses.  The
value is the value of \[EXPR\].}

\RULE{[ FORMER ]}
\COMMENT{Evaluates to the tuple of those values generated by
\[FORMER\] in the order that former generates them.}

\RULE{\{ FORMER \}}
\COMMENT{Evaluates to the set of those values generated by
\[FORMER\]\@.}

\index{length (# tt)\\of a string}%
\index{length (# tt)\\of a tuple}%
\index{cardinality (# tt) of a set}%
\RULE{\# EXPR}
\COMMENT{\[EXPR\] must be a set, tuple, or string. 
The value is
the cardinality of the set, the length of the tuple,
or the length of the string.}

\RULE{not EXPR}\key{not}
\COMMENT{
Logical negation.
\[EXPR\] must evaluate to Boolean.
}

\RULE{+ EXPR}\key{+}
\COMMENT{
Identity function.
\[EXPR\] must evaluate to a number.
}

\RULE{- EXPR}\key{-}
\COMMENT{
Negative of \[EXPR\]\@.
\[EXPR\] must evaluate to a number.
}

\RULE{EXPR SELECTOR}
\COMMENT{\[EXPR\] must evaluate to an \ISETL{} value that is, in the
general sense, a function.  That is, it must be a map,
tuple, string, or func.
See section~\ref{selector}.}   

\RULE{EXPR . ID EXPR}
\COMMENT{This is equivalent to \[ID(EXPR,EXPR)\].  
It lets you use a binary function as an \XX{infix operator}.
The space after the ``\[.\]'' is optional.
}

\RULE{EXPR . (EXPR) EXPR}
\COMMENT{This is equivalent to \[(EXPR)(EXPR,EXPR)\].  
It lets you use a binary function as an \XX{infix operator}.
The space after the ``\[.\]'' is optional.
}

\medskip
\noindent
In general, arithmetic operators and comparisons may mix integers and 
floating\_\,point.
The result of an arithmetic operation is an integer
if both operands are integers and
floating\_\,point otherwise.
For simplicity, we will use the term number to mean a value that
is either integer or floating\_\,point.

\nopagebreak
\noindent
Possible operators are:
\key{/} \key{div} \key{mod} 
\key{with} \key{less}
\key{union} \key{inter} \key{in} \key{notin} \key{subset}
\key{and} \key{or} \key{impl} \key{iff} 
\index{intersection (* tt, inter tt, zinter)}
\index{replication (* tt)\\string}
\index{replication (* tt)\\tuple}
\index{exponentiation (** tt)}
\index{concatenation (+ tt)\\string}
\index{concatenation (+ tt)\\tuple}
\index{union (+ tt, union tt, zunion)}
\index{difference (- tt) of two sets}
\index{equal}
\index{relational operators}

\nopagebreak
{\tt
\CS \samepage
+ - * / div mod ** \\*
with less \\*
= /= < > <= >= \\*
union inter in notin subset \\*
and or impl iff
\CE
}

\nopagebreak
\noindent
See section~\ref{prec} for precedence rules.

\noindent
Any cases not covered in the explanation for an operator will result
in an error.
For an explanation of errors, see section~\ref{secRT}.


\RULE{EXPR + EXPR}
\COMMENT{If both instances of \[EXPR\] evaluate to 
numbers, this is addition.
If both instances of \[EXPR\] evaluate to sets, then this
is union.
If both instances of \[EXPR\] evaluate to tuples or strings,
then this is concatenation.}

\RULE{EXPR union EXPR}
\COMMENT{An alternate form of \[+\].
It is intended that it be used with sets, but it is in all ways
equivalent to \[+\].}

\RULE{EXPR - EXPR}
\COMMENT{If both instances of \[EXPR\] evaluate to
numbers, this is subtraction.
If both instances of \[EXPR\] evaluate to sets, then this
is set difference.}

\RULE{EXPR * EXPR}
\COMMENT{If both instances of \[EXPR\] evaluate to numbers,
this is multiplication.
If both evaluate to sets, this is intersection.
If one instance of \[EXPR\] evaluates to integer
and the other to a tuple or string, then the value is
the tuple or string, concatenated with itself the
integer number of times, if the integer is positive;
and the empty tuple or string, if the integer is less than or
equal to zero.}

\RULE{EXPR inter EXPR}
\index{intersection (* tt, inter tt, zinter)}
\COMMENT{An alternate form of \[*\].
It is intended that it be used with sets, but it is in all ways
equivalent to \[*\].}

\RULE{EXPR / EXPR}
\COMMENT{Both instances of \[EXPR\] must evaluate to numbers.
The value is the result of division
and is of type floating\_\,point.}

\RULE{EXPR div EXPR}
\COMMENT{Both instances of \[EXPR\] must evaluate to integer, and the
second must be non-zero.  The value is integer division
defined by the following two relations,

    \DS
    $(a \div b) * b + (a \mod b) = a$\ \ \     \=	{\rm for} $b>0$\\
    $a \div (-b) = -(a \div b)$	               \>	{\rm for} $b<0$.\\
    \DE
}

\RULE{EXPR mod EXPR}
\COMMENT{Both instances of \[EXPR\] must evaluate to integer and the
second must be non-zero.  The result is the remainder,
and the following condition is always satisfied,

    \CS$0 \leq a \mod b < | b |$.\CE}

\RULE{EXPR ** EXPR}
\COMMENT{The values of the two expressions must be numbers.
The operation is exponentiation.
}

\RULE{EXPR with EXPR}
\COMMENT{The value of the first \[EXPR\] must be a set or tuple.  If
it is a set, the value is that set with the value of the
second \[EXPR\] added as an element.  If it is a tuple,
the value of the second \[EXPR\] is assigned to the value
of the first component after the last defined component
of the tuple.}

\RULE{EXPR less EXPR}
\COMMENT{The value of the first \[EXPR\] must be a set.  
The value is
that set with the value of the second \[EXPR\] removed, if it
was present;
the value of the first \[EXPR\], if the second was not present.}

\RULE{EXPR = EXPR}
\COMMENT{The test for equality of any two \ISETL{} values.}

\RULE{EXPR /= EXPR}
\COMMENT{Negation of \[EXPR=EXPR\]\@.}

\RULE{EXPR <  EXPR}
\RULE{EXPR >  EXPR}
\RULE{EXPR <= EXPR}
\RULE{EXPR >= EXPR}
\COMMENT{
For all the above inequalities,
both instances of \[EXPR\] must evaluate to the same
type, which must be number or string.
For numbers, this is the test for the
standard arithmetic ordering; for strings, it
is the test for lexicographic ordering.}

\RULE{EXPR in EXPR}
\COMMENT{The second \[EXPR\] must be a set, 
tuple, or string.  For
sets and tuples, this is the test for membership
of the first in the second.
For strings, it is the test for substring.}

\RULE{EXPR notin EXPR}
\COMMENT{Negation of \[EXPR in EXPR\]\@.}

\RULE{EXPR subset EXPR}
\COMMENT{Both instances of \[EXPR\] must be sets.  This is the
test for the value of the first \[EXPR\] to be
a subset of the value of the second \[EXPR\]\@.}

\RULE{EXPR and EXPR}
\COMMENT{
Logical conjunction.
Both instances of \[EXPR\] should evaluate to a Boolean.
If the left operand is false, the right operand is not evaluated.
Actually returns the second argument, if the first is \[true\].
While the user may depend on the left-to-right evaluation order,
it is recommended that they not depend on the behavior when the second
argument is not Boolean.}

\RULE{EXPR or EXPR}
\COMMENT{
Logical disjunction.
Both instances of \[EXPR\] should evaluate to a Boolean.
If the left operand is true, the right operand is not evaluated.
Actually returns the second argument, if the first is \[false\].
While the user may depend on the left-to-right evaluation order,
it is recommended that they not depend on the behavior when the second
argument is not Boolean.}

\RULE{EXPR impl EXPR}
\COMMENT{
Logical implication.
Both instances of \[EXPR\] must evaluate to a Boolean.
}

\RULE{EXPR iff EXPR}
\COMMENT{
Logical equivalence.
Both instances of \[EXPR\] should evaluate to a Boolean.
It actually checks for equality, like \[=\], but it has a different
precedence.
It is recommended that the user not depend on \[iff\] to work with
arguments other than Booleans.}

\RULE{\% BINOP EXPR}\index{zpercent tt}
\index{generalize operation}
\index{compound operator (% tt)}%
\COMMENT{\[EXPR\] must evaluate to a set, tuple, or string.
Say that the elements in
\[EXPR\] are \[x1\], \[x2\],\ldots,\[xN\] (\[N=\#EXPR\]).
If \[N=0\], then the value is \[OM\]\@.
If \[N=1\], then the value is the single element.
Otherwise, \[\%$\oplus$~EXPR\] equals
\DS
x1 $\oplus$ x2 $\oplus$ $\cdots$ $\oplus$ xN 
\DE
associating to the left.

If \[EXPR\] is a set, then the selection of elements is
made in arbitrary order, otherwise it is made in
the order of the components of \[EXPR\]\@.}

\RULE{EXPR \% BINOP EXPR}
\COMMENT{The second instance of \[EXPR\] must evaluate to a set,
tuple, or string.
If the first \[EXPR\] is \[a\],
\[BINOP\] is \(\oplus\), and the values in the second are
\[x1\], \[x2\],\ldots,\[xN\] as above, then the value is:
\DS
a $\oplus$ x1 $\oplus$ x2 $\oplus$ $\cdots$ $\oplus$ xN 
\DE
associating to the left.
}

\RULE{EXPR ? EXPR}\key{?}
\COMMENT{The value of the first \[EXPR\], if it is not \[OM\]; otherwise
the value of the second \[EXPR\]\@.}

\RULE{choose ITER-LIST | EXPR}\key{choose}
\COMMENT{Returns the first set of iterator values that satisfies EXPR.
The value returned depends on the type of iterators.

\begin{tabular}{l l}
     Iterator&					Returns\\
     ========&					=======\\
     \tt x in S&				\tt x\\
     \tt x in S, y in T&			\tt [x,y]\\
     \tt x,y in S&			       	\tt [x,y]\\
     \tt y=f(x)&				\tt [x,y]\\
     \tt y=f(x), a=g(b)&			\tt [[x,y], [a,b]]\\
     \tt y=f\{x\}&				\tt [x,y],  where y is a set
\end{tabular}
}

\RULE{exists ITER-LIST | EXPR}
\key{exists}
\COMMENT{\[EXPR\] must evaluate to a Boolean.
If \[ITER-LIST\] generates at least
one instance in which \[EXPR\] evaluates to true, then the
value is true; otherwise it is false.}

\RULE{forall ITER-LIST | EXPR}
\key{forall}
\COMMENT{\[EXPR\] must evaluate to a Boolean.  If every instance
generated by \[ITER-LIST\] is such that \[EXPR\] evaluates to
true, then the value is true; otherwise it is false.}

\RULE{EXPR where DEFNS end}
\key{where}\key{end}
\COMMENT{The value is the value of the \[EXPR\] preceding \[where\],
evaluated in the current environment with the \[ID\]s in
the \[DEFNS\] added to the environment and initialized to
the corresponding \[EXPR\]s.  The scope of the \[ID\]s is
limited to the \[where\] expression.
The \[DEFNS\] can modify \[ID\]s defined in earlier \[DEFNS\] in the
same \[where\] expression.
}

\RULE{EXPR @ EXPR}
\key{@}\label{tuple-at}
\COMMENT{The first expression must be an integer \[i\] and the second
a tuple \[T\]\@.
The result is a tuple consisting of the same sequence as \[T\], but
with the first index being \[i\].}

\HEAD{BINOP}
\RULE{\rm ``Any binary operator or an \[ID\] or expression in parentheses
whose value is a function of two parameters.
The \[ID\] and parenthesized expression may be preceded by a period.''}
\COMMENT{
The acceptable binary operators are:
\[+\], \[-\], \[*\], \[**\], \[union\], \[inter\],
\[/\], \[div\], \[mod\], \[with\], \[less\], \[and\], \[or\],
\[impl\].}

\HEAD{DEFNS}
\RULE{\rm ``Zero or more instances of \[DEFN\].
The final semicolon is optional.''}

\HEAD{DEFN}
\RULE{BOUND := EXPR ;}

\RULE{ID SELECTOR := EXPR ;}

\HEAD{EXPR-LIST}
\RULE{\rm ``One or more instances of \[EXPR\] separated by commas.''}

\subsection{Function Constants}\label{func-const}
\HEAD{FUNC-CONST}
\RULE{FUNC-HEAD LOCALS VALUES STMTS end}
\COMMENT{This is the syntax for user-defined funcs.
One may optionally close with \[end~func\].
\[VALUES\] and \[LOCALS\] may be repeated or omitted
and appear in any order.

See \[return\] on page~\pageref{return}.
}

\RULE{: ID-LIST OPT-PART -> EXPR :}
\COMMENT{An abbreviation for
\[func( ID-LIST OPT-PART ); return EXPR; end\]
}

\HEAD{FUNC-HEAD}
\RULE{func ( ID-LIST OPT-PART ) ;}
\key{func}
\COMMENT{In this case, there are parameters.
The parameters in the \[OPT-PART\] receive the value
\[om\] if there are no corresponding arguments.}

\RULE{func ( OPT-PART ) ;}
\COMMENT{In this case, there are no required parameters.}

\RULE{proc ( ID-LIST OPT-PART ) ;}
\key{proc}
\RULE{func ( OPT-PART ) ;}
\COMMENT{Just like \[func\], but no value may be returned in the
return statement.  Values of type \[proc\] should only be used as statements.
}

\HEAD{OPT-PART}
\RULE{opt ID-LIST}
\key{opt}
\COMMENT{\rm ``May be omitted.''}

\HEAD{LOCALS}
\RULE{local ID-LIST ;}

\HEAD{VALUES}
\RULE{value ID-LIST ;}

\HEAD{ID-LIST}
\RULE{\rm ``One or more instances of \[ID\] separated by commas.''}

}
